<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Iambangbang 的博客</title>
  
  <subtitle>喜欢web和写诗</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-09-28T20:27:37.270Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Iambangbang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PHP伪协议简析</title>
    <link href="http://yoursite.com/2017/09/28/php-filter/"/>
    <id>http://yoursite.com/2017/09/28/php-filter/</id>
    <published>2017-09-28T20:21:41.000Z</published>
    <updated>2017-09-28T20:27:37.270Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PHP伪协议简析"><a href="#PHP伪协议简析" class="headerlink" title="PHP伪协议简析"></a>PHP伪协议简析</h1><h3 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h3><p>第一次写博客，写的不好，还望看到的师傅们能够海涵，之前一直比较懒，很多东西想写，但又懒得写，最后觉得还是写下来，总结一下也能加深理解。这段时间一直看到伪协议的题目，包括比赛中，伪协议也是比较重要的考察方式，于是在看了众多师傅的博客之后，对比官方文档，写了这篇简析，本文并没有对所有的伪协议都作分析，只是对简单的几个进行分析。</p><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>PHP 带有很多内置 URL 风格的封装协议，可用于类似 fopen()、 copy()、 file_exists() 和 filesize() 的文件系统函数。 除了这些封装协议，还能通过 stream_wrapper_register() 来注册自定义的封装协议。（官方文档）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">1. file:// — 访问本地文件系统</div><div class="line">2. http:// — 访问 HTTP(s) 网址</div><div class="line">3. ftp:// — 访问 FTP(s) URLs</div><div class="line">4. php:// — 访问各个输入/输出流（I/O streams）</div><div class="line">5. zlib:// — 压缩流</div><div class="line">6. data:// — 数据（RFC 2397）</div><div class="line">7. glob:// — 查找匹配的文件路径模式</div><div class="line">8. phar:// — PHP 归档</div><div class="line">9. ssh2:// — Secure Shell 2</div><div class="line">10. rar:// — RAR</div><div class="line">11. ogg:// — 音频流</div><div class="line">12. expect:// — 处理交互式的流</div></pre></td></tr></table></figure></p><h3 id="php"><a href="#php" class="headerlink" title="php://"></a>php://</h3><h4 id="php-input"><a href="#php-input" class="headerlink" title="php://input"></a>php://input</h4><p>php://input代表可以访问请求的原始数据，简单来说POST请求的情况下，php://input可以获取到post没有解析的原始数据，下面是一个简单的例子，</p><p><img src="/2017/09/28/php-filter/001.png" alt="1"><br>当开启了allow_url_include=on的时候，就可以造成任意代码攻击。<br>注意！当enctype=”mutipart/form-data”的时候php://input是无效的</p><h4 id="php-output"><a href="#php-output" class="headerlink" title="php://output"></a>php://output</h4><p>php://output只是一个只写数据流，允许使用print和echo写入到输出的缓冲区</p><h4 id="php-filter"><a href="#php-filter" class="headerlink" title="php://filter"></a>php://filter</h4><p>这个是比较关键的，也是比赛中常见的，php://filter 是一种元封装器， 设计用于数据流打开时的筛选过滤应用。 这对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、 file() 和 file_get_contents()， 在数据流内容读取之前没有机会应用其他过滤器。事实上，在include函数的使用上，经常会造成任意文件读取漏洞，而file_get_contents()和file_put_contents()这样函数下，常常会构成getshell等更严重的漏洞。<br>php://filter 目标使用以下的参数作为它路径的一部分。 复合过滤链能够在一个路径上指定。<br>举个例子，常见的读取任意文件的payload<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1 php://filter/read=convert.base64-encode/resource=xxx.php</div></pre></td></tr></table></figure></p><p>这里读的过滤器是convert.base64-encode，作用是把输入的数据base64进行加密，resource=xxx.php，作用是读取xxx.php的内容</p><p>这里顺便介绍几类<a href="http://php.net/manual/zh/filters.php" target="_blank" rel="external">过滤器</a></p><h5 id="转换过滤器-convert"><a href="#转换过滤器-convert" class="headerlink" title="转换过滤器(convert.*)"></a>转换过滤器(convert.*)</h5><p>convert.*是php5.0.0之后添加的，主要有convert.base64-encode、convert.base64-decode、convert.quoted-printable-encode和convert.quoted-printable-decode几种过滤器，其中convert.quoted-printable-encode和convert.base64-encode都支持一个关联数组给出的参数，如果给出line-length，则可以将输出截成以line-length为长度的块，如果给出了line-break-chars，每块将被用给出的字符隔开</p><h5 id="字符串过滤器-string"><a href="#字符串过滤器-string" class="headerlink" title="字符串过滤器(string.*)"></a>字符串过滤器(string.*)</h5><p>说的夸张点儿，string.*就是python里的string模块，不过还是有一定的区别。<br>string.rot13，string.toupper，string.tolower，都可以直接看出他们的作用，这里需要解释一个string.strip_tags过滤器，这个过滤器是从php5.0.0启用的，作用等同于strip_tags()函数处理的结果。</p><h5 id="压缩过滤器-zlib"><a href="#压缩过滤器-zlib" class="headerlink" title="压缩过滤器(zlib.*)"></a>压缩过滤器(zlib.*)</h5><p>zlib.*压缩过滤器从pph5.1.0版本启用，在激活zlib的前提下，可以通过安装来自PECL的zlib_filter包作为一个后门，zlib.deflate和zlib.inflate是两个主要过滤器。</p><h5 id="加密过滤器-mcrypt-和mdecrypt"><a href="#加密过滤器-mcrypt-和mdecrypt" class="headerlink" title="加密过滤器(mcrypt.和mdecrypt.)"></a>加密过滤器(mcrypt.<em>和mdecrypt.</em>)</h5><p>mcrpt.<em>和mdecrypt.</em>使用libmecrypt提供对称加密和解密，细节的话，大家可以去看下官方的文档。</p><p>总的来说php://filter的东西还是蛮多的，这里不举实际的例子了，因为实在太多，想了解细节的话可以去看p神的这篇<a href="https://www.leavesongs.com/PENETRATION/php-filter-magic.html" target="_blank" rel="external">博文</a></p><h4 id="php-stdin"><a href="#php-stdin" class="headerlink" title="php://stdin"></a>php://stdin</h4><p>这个主要用于php cli的输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">$line = fopen(&apos;php://stdin&apos;,&apos;r&apos;);</div><div class="line">echo fgets($line);</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p><p><img src="/2017/09/28/php-filter/002.png" alt="2"></p><h4 id="php-stdout"><a href="#php-stdout" class="headerlink" title="php://stdout"></a>php://stdout</h4><p>这个主要用于php cli的输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;?php  </div><div class="line">$fh = fopen(&apos;php://stdout&apos;, &apos;w&apos;);  </div><div class="line">fwrite($fh, &quot;标准输出php://stdout\n&quot;);  </div><div class="line">fclose($fh);  </div><div class="line">fwrite(STDOUT, &quot;标准输出STDOUT\n&quot;);  </div><div class="line">?&gt;</div></pre></td></tr></table></figure></p><p><img src="/2017/09/28/php-filter/003.png" alt="3"></p><h3 id="except"><a href="#except" class="headerlink" title="except://"></a>except://</h3><p>可以通过except://command执行任意linux指令，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;?php  </div><div class="line">$code = $_GET[&apos;hax&apos;];  </div><div class="line">include($code);  </div><div class="line">?&gt;</div></pre></td></tr></table></figure></p><p>注意！该协议默认未开启，如果要使用的话要先安装PECL上的Except扩展</p><h3 id="data"><a href="#data" class="headerlink" title="data://"></a>data://</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;?php  </div><div class="line">$code = $_GET[&apos;hax&apos;];  </div><div class="line">include(&quot;$code&quot;);  </div><div class="line">?&gt;</div></pre></td></tr></table></figure><p>当开启了allow_url_include打开的时候，任意文件包含就变成了任意命令执行。<br>这里积累一个姿势，通过data伪协议实现图片木马，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;?php </div><div class="line">　　$jpegimage = imagecreatefromjpeg(&quot;data://image/jpeg;base64,&quot; . base64_encode($sql_result_array[&apos;imagedata&apos;])); </div><div class="line">?&gt;</div></pre></td></tr></table></figure></p><h3 id="glob"><a href="#glob" class="headerlink" title="glob://"></a>glob://</h3><p>这个协议是查找匹配的文件路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">　　// 循环 ext/spl/examples/ 目录里所有 *.php 文件</div><div class="line">　　// 并打印文件名和文件尺寸</div><div class="line">　　$it = new DirectoryIterator(&quot;glob://E:\\wamp\\www\\test\\*.php&quot;);</div><div class="line">　　foreach($it as $f) </div><div class="line">　　&#123;</div><div class="line">　　　　printf(&quot;%s: %.1FK\n&quot;, $f-&gt;getFilename(), $f-&gt;getSize()/1024);</div><div class="line">　　&#125;</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p><h3 id="phar"><a href="#phar" class="headerlink" title="phar://"></a>phar://</h3><p>这个伪协议有官方的<a href="http://php.net/manual/en/intro.phar.php" target="_blank" rel="external">文档</a><br>类似 Java 的 jar 包，是个压缩文件，在 PHP5.3 版本之后出现；<br>其出现本意是方便程序员将程序打包部署到线上机器，但可在别<br>处发挥利用；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">include &apos;phar:///path/to/myphar.phar/file.php&apos;;</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p><p>在存在包含漏洞的前提下，可以创建一个php文件，然后用上面的代码包含执行，也可以在url直接访问。<br>注意！这里除了phar压缩包，就只能用zip来解压，rar压缩是不被识别的。<br>而且，这个伪协议的使用，并不需要php.ini的allow_url_include开启，<br>默认即可识别。<br>一般比赛中的套路是，先写一句话，然后重命名为jpg，再进行压缩上传，最后用phar://伪协议访问</p><p>在最后抄下师傅做的表格，做个总结</p><table><thead><tr><th>包装或协议</th><th>控制能力</th><th>allow_url_include</th><th>漏洞类型</th></tr></thead><tbody><tr><td>file://</td><td>-</td><td>Off</td><td>LFI /文件操作</td></tr><tr><td>glob://</td><td>-</td><td>Off</td><td>目录遍历</td></tr><tr><td>php://filter/read</td><td>include</td><td>Off</td><td>文件泄露</td></tr><tr><td>php://filter/write</td><td>file_put_contents</td><td>Off</td><td>编码</td></tr><tr><td>php://input</td><td>include</td><td>On</td><td>RCE</td></tr><tr><td>data://</td><td>include</td><td>On</td><td>RCE</td></tr><tr><td>zip://</td><td>include + uploaded file</td><td>Off</td><td>RCE</td></tr><tr><td>phar://</td><td>include + uploaded file</td><td>Off</td><td>RCE</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PHP伪协议简析&quot;&gt;&lt;a href=&quot;#PHP伪协议简析&quot; class=&quot;headerlink&quot; title=&quot;PHP伪协议简析&quot;&gt;&lt;/a&gt;PHP伪协议简析&lt;/h1&gt;&lt;h3 id=&quot;写在开头&quot;&gt;&lt;a href=&quot;#写在开头&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/09/27/hello-world/"/>
    <id>http://yoursite.com/2017/09/27/hello-world/</id>
    <published>2017-09-27T11:23:03.840Z</published>
    <updated>2017-09-27T11:23:03.840Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
